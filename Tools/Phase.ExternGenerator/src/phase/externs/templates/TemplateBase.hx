package phase.externs.templates;

import haxe.rtti.CType;
import haxe.rtti.CType.ClassField;
import haxe.rtti.CType.PathParams;
import haxe.ds.StringMap;
import phase.externs.Generator;

class TemplateBase extends CodeWriter
{
	public var haxePath:String;
	public var haxePackage:String;
	
	public var namespaceParts:Array<String>;
	public var namespace:String;
	public var name:String;
	public var generator:Generator;
	
	private var _dynamicAsObject:Bool;
	private var _currentFieldNames:Array<String>;
	private var _useStandardTypes:Bool;
	
	private function new(generator:Generator, path:String) 
	{
		super();
		
		this.generator = generator;
		
		haxePath = path;
		namespaceParts = path.split('.'); 
		name = namespaceParts.pop();
		
		haxePackage = namespaceParts.join(".");
		
		if (namespaceParts.length == 0 && generator.toplevelPackage != null && generator.toplevelPackage != '')
		{
			namespaceParts.insert(0, generator.toplevelPackage);
		}
		
		if (generator.libraryNamespace != null && generator.libraryNamespace != '')
		{
			namespaceParts.insert(0, generator.libraryNamespace);	
		}
				
		namespace = '';
		for (i in 0 ... namespaceParts.length)
		{
			if (namespace.length > 0) namespace += ".";
			namespaceParts[i] = toCamelCase(namespaceParts[i]);
			namespace += namespaceParts[i];
		}
	}
	
	public function generate()
	{
		_dynamicAsObject = true;
		writeLine("//------------------------------------------------------------------------------");
		writeLine("// <auto-generated>");
		writeLine("//     This code was generated by a the Phase Extern Generator");
		writeLine("//     Changes to this file will be lost if the code is regenerated.");
		writeLine("// </auto-generated>");
		writeLine("//------------------------------------------------------------------------------");
		writeLine("");
		writeLine("using System;");
		writeLine("using Phase;");
		writeLine("using Phase.Attributes;");

		writeLine('namespace $namespace');
		beginBlock();
		
		generateType();
		
		endBlock();
		
		return toString();
	}
	
	private function generateType()
	{
	}

	private function writePathParams(p:PathParams)
	{
		if (p.path == "Int")
		{
			if (_useStandardTypes) 
			{
				write("int");
			}
			else
			{
				write("Haxe.HaxeInt");
			}
			return;
		}
		if (p.path == "Float")
		{
			if (_useStandardTypes) 
			{
				write("double");
			}
			else
			{
				write("Haxe.HaxeFloat");
			}
			return;
		}
		if (p.path == "Bool")
		{
			if (_useStandardTypes) 
			{
				write("bool");
			}
			else
			{
				write("Haxe.HaxeBool");
			}
			return;
		}
		if (p.path == "String")
		{
			if (_useStandardTypes) 
			{
				write("string");
			}
			else
			{
				write("Haxe.HaxeString");
			}
			return;
		}
		if (p.path == "Array")
		{
			write("Haxe.HaxeArray<");
			writeIterable(p.params, writeType);
			write(">");
			return;
		}
		
		
		
		var path = p.path;
		var skipTopLevel = false;
		
		var nested = haxePath + ".";
		var nestedPrivate = haxePackage + "._" + name + ".";
		
		if (path.indexOf(nested) == 0)
		{
			path = path.substr(nested.length);
			skipTopLevel = true;
		}
		else if (path.indexOf(nestedPrivate) == 0)
		{
			path = path.substr(nestedPrivate.length);
			skipTopLevel = true;
		}
		else if (path == haxePath && haxePackage.length > 0)
		{
			path = path.substr(haxePackage.length + 1);
			skipTopLevel = true;
		}
		else if(_currentFieldNames != null)
		{
			// looks like haxe sometimes reuses type parameters of other methods, so we search for potential candidates and trim them
			for (name in _currentFieldNames)
			{
				var dotName = name + ".";
				if (path.indexOf(dotName) == 0)
				{
					path = path.substr(dotName.length);
					skipTopLevel = true;
					break;	
				}
			}
		}
		
		var parts = path.split('.');
		
		if (!skipTopLevel)
		{
			if (parts.length == 1 && generator.toplevelPackage != null && generator.toplevelPackage != '')
			{
				parts.insert(0, generator.toplevelPackage);
			}
			
			if (generator.libraryNamespace != null && generator.libraryNamespace != '')
			{
				parts.insert(0, generator.libraryNamespace);	
			}
		}
		
		var name = parts.pop();
		
		for (p in parts)
		{
			write(p.substr(0, 1).toUpperCase());
			write(p.substr(1));
			write(".");
		}
		
		write(name);
		
		if (p.params.length > 0)
		{
			write("<"); 
			
			writeIterable(p.params, writeType);
			
			write(">");
		}
	}
	
	private function toCamelCase(s:String)
	{
		return s.substring(0, 1).toUpperCase() + s.substring(1);
	}
	
	private function writeType(t:CType) : Void
	{
		switch(t)
		{
			case CUnknown:
				write("object");
			case CEnum( name , params ):
				writePathParams({
					path: name,
					params: params
				});
			case CClass( name , params ):
				writePathParams({
					path: name,
					params: params
				});
			case CTypedef( name , params  ):
				writePathParams({
					path: name,
					params: params
				});
			case CFunction( args , ret ):
				
				var isVoid = false;
				switch(ret)
				{
					case CUnknown:
						isVoid = true;
					case CClass( name , params ):
						isVoid = name == "Void";
					case CAbstract( name , params  ):
						isVoid = name == "Void";
					case CTypedef( name , params  ):
						isVoid = name == "Void";
					default:
						isVoid = false;
				}
				
				if (isVoid)
				{
					write("Action<");
				}
				else
				{
					write("Func<");
				}
				
				// TODO: handle optionals (requires delegate generation)
				writeIterable(args, function(arg){
					writeType(arg.t);
				});
				
				if (!isVoid)
				{
					if (args.length > 0)
					{
						write(", ");
					}
					writeType(ret);
				}
				write(">");
			case CAnonymous( fields ):
				write("dynamic");
			case CDynamic( t ):
				if (_dynamicAsObject) {
					write("object");	
				}
				else {
					write("dynamic");
				}				
			case CAbstract( name , params ):
				if (name == "Void")
				{
					write("void");
				}
				else
				{
					writePathParams({
						path: name,
						params: params
					});	
				}
		}
	}
	
	private static var reservedName:StringMap<Bool> = (function() {
		var reserved = new StringMap<Bool>();
		reserved.set("abstract", true);
		reserved.set("as", true);
		reserved.set("base", true);
		reserved.set("bool", true);
		reserved.set("break", true);
		reserved.set("byte", true);
		reserved.set("byte", true);
		reserved.set("case", true);
		reserved.set("catch", true);
		reserved.set("char", true);
		reserved.set("checked", true);
		reserved.set("class", true);
		reserved.set("const", true);
		reserved.set("continue", true);
		reserved.set("decimal", true);
		reserved.set("default", true);
		reserved.set("delegate", true);
		reserved.set("do", true);
		reserved.set("double", true);
		reserved.set("double", true);
		reserved.set("else", true);
		reserved.set("enum", true);
		reserved.set("event", true);
		reserved.set("explicit", true);
		reserved.set("extern", true);
		reserved.set("false", true);
		reserved.set("finally", true);
		reserved.set("fixed", true);
		reserved.set("float", true);
		reserved.set("for", true);
		reserved.set("foreach", true);
		reserved.set("goto", true);
		reserved.set("if", true);
		reserved.set("implicit", true);
		reserved.set("in", true);
		reserved.set("int", true);
		reserved.set("interface", true);
		reserved.set("internal", true);
		reserved.set("is", true);
		reserved.set("List", true);
		reserved.set("lock", true);
		reserved.set("long", true);
		reserved.set("namespace", true);
		reserved.set("new", true);
		reserved.set("null", true);
		reserved.set("object", true);
		reserved.set("object", true);
		reserved.set("operator", true);
		reserved.set("out", true);
		reserved.set("override", true);
		reserved.set("params", true);
		reserved.set("private", true);
		reserved.set("protected", true);
		reserved.set("public", true);
		reserved.set("readonly", true);
		reserved.set("ref", true);
		reserved.set("return", true);
		reserved.set("sbyte", true);
		reserved.set("sbyte", true);
		reserved.set("sealed", true);
		reserved.set("short", true);
		reserved.set("sizeof", true);
		reserved.set("Stack", true);
		reserved.set("stackalloc", true);
		reserved.set("static", true);
		reserved.set("string", true);
		reserved.set("struct", true);
		reserved.set("switch", true);
		reserved.set("this", true);
		reserved.set("throw", true);
		reserved.set("true", true);
		reserved.set("try", true);
		reserved.set("typeof", true);
		reserved.set("uint", true);
		reserved.set("ulong", true);
		reserved.set("unchecked", true);
		reserved.set("unsafe", true);
		reserved.set("ushort", true);
		reserved.set("using", true);
		reserved.set("var", true);
		reserved.set("virtual", true);
		reserved.set("void", true);
		reserved.set("volatile", true);
		reserved.set("while", true);
		return reserved;
	})();
	
	private function writeName(s:String, allowClassName:Bool)
	{
		if (reservedName.exists(s))
		{
			write("@");
		}
		if (s == name && !allowClassName)
		{
			write("_");
		}
		write(s);
	}
	
	private function isField(f:ClassField)
	{
		switch(f.get)
		{
			case RNormal:
				return true;
			default:
				return false;
		}
	}
	
	private function isMethod(f:ClassField)
	{
		var isInline = false;
		var isMethod = false;
		switch (f.set) {
			case RNo:
			case RCall(_):
			case RMethod:
				isMethod = true;
			case RDynamic:
				isMethod = true;
			default:
		}
		switch (f.get) {
			case RNo:
			case RCall(_):
			case RDynamic:
			case RInline:
				isInline = true;
			default:
		}
		if (isMethod || isInline) 
		{
			switch (f.type)
			{
				case CFunction(args, ret):
					return true;
				default:
					return false;
			}
		}
		else
		{
			return false;
		}
	}
	
	private function getFieldType(f:ClassField)
	{
		if (isMethod(f))
		{
			switch(f.type)
			{
				case CFunction(args, ret):
					return ret;
				default:
					return f.type;
			}
		}
		else
		{
			return f.type;
		}
	}
	
	private function getMethodParameters(f:ClassField) : List<FunctionArgument>
	{
		switch(f.type)
		{
			case CFunction(args,ret):
				return args;
			default:
				return null;
		}
	}

	private function println(s:Dynamic)
	{
		Sys.println(s);
	}
}